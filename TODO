* Make use of erlcfg
* add commands to simreg script via nodetool:
    start/stop/status tx_nanny
    start/stop/status rx_nanny
    start/stop/status webservice
    start/stop/status txq
    add/remove/view sms alert list
    send an sms
    get statistics on webservice tps
    get statistics on tx 
    get statistics on rx tps

* Pull out all other constants into config file
* Stopping the application does not clean-up the esme's properly :(
* backoff DETS garbage collection
* When nanny goes down, take down your kids dammit!!!
  alternatively, find a way to make it such that a new nanny
  will discover the kids which are still alive,

* In backoff, instead of using a DETS, still use an ETS, but implement
  dynamic registration, so a client can register if its not already 
  registered and see if its possible to also let a backoff module
  discover clients who want its services... 

* Log and track:
    webservice transactions 

* Fully flesh out the mini pluggin framework in the rx module to allow the
  rx to notify all registered callbacks, instead of just the one
  callback. This should be a gen_event based framework

* implement gen_sms_handler:send(Src, Dst, Msg) which will use 
  preconfigured defaults for the plugin for the remaining #submit_sm{} parameters

* esmerx should implement a routing table:
        {Dst, SEPARATOR} -> Callback |
        {{Dst, Src}, SEPARATOR} -> Callback
        {{Dst, Src, [H0,H1,...,Hn|R]}, SEPARATOR} -> Callback

  Also, we would have URL schemes for the various Callback types, e.g.:
        {erlang, Modulename}
        {http, http://foo..areas/, get, json}
        {http, http://.../, post, xml}


* Support global configs for all tx/rx and per instance configuration
  overriding, this would allow, different one application to use say multiple
  smsc accounts for proper load-balancing, etc.

  Also, extend this to support virtual instances, which would basically be like
  the entire application with its own seperate configuration, running still
  inside one vm instance.

* Start employing erlang:monitor/2 across board to handle garbage collection of
  dead/dying procs:
    * backoff needs to deregister its dying clients
    * nanny's need to deregister their dying kids so when the new ones
      come back, they can replace them cleanly.
    * other such shenanigans :)
