* implement a pluggin framework in the rx module that allows the
  rx to notify all registered callbacks, instead of just the one
  callback.

  In this framework, define an gen_sms behaviour that all plugins
  will implement. This gen_sms behaviour module will also export
  gen_sms:send(Src, Dst, Msg), which will use preconfigured defaults
  for the plugin for the remaining #submit_sm{} parameters
* Make use of erlcfg
* Make use of log4erl?
* add commands to simreg script via nodetool:
    start/stop/status tx_nanny
    start/stop/status rx_nanny
    start/stop/status webservice
    start/stop/status txq
    add/remove/view sms alert list
    send an sms
    get statistics on webservice tps
    get statistics on tx 
    get statistics on rx tps

* Pull out all other constants into config file
* Stopping the application does not clean-up the esme's properly :(
* backoff DETS garbage collection
* When nanny goes down, take down your kids dammit!!!
  alternatively, find a way to make it such that a new nanny
  will discover the kids which are still alive,

* In backoff, instead of using a DETS, still use an ETS, but implement
  dynamic registration, so a client can register if its not already 
  registered and see if its possible to also let a backoff module
  discover clients who want its services... 

* Log and track:
    webservice transactions 
    esmerx transactions

    For these, make them different from the actual business logic optional
    logging

* Proposal for esmerx logging. Also some more ideas:
     -> Node|Tid|Tstmp | RxId|RxPid | Src|Dst|ShortMessage | Callback|
     <- Node|Tid|Tstmp | Status

     The callback modules should expose:
        Callback:init(...) -> will be called by esmerx in handle_bind()
        Callback:terminate/2 -> will be called when esmerx is going down.
        Callback:handle_sms(...) -> {noreply, {StatusCode, StatusMessage, Extra}, State}
                                  | {reply, ShortMsg, {StatusCode, StatusMessage, Extra}, State}
                                  | {late_reply, Ref, State}

    esmerx would then implement a routing table:
        {Dst, SEPARATOR} -> Callback |
        {{Dst, Src}, SEPARATOR} -> Callback
        {{Dst, Src, [H0,H1,...,Hn|R]}, SEPARATOR} -> Callback

    Also, we would have URL schemes for the various Callback types, e.g.:
        {erlang, Modulename}
        {http, http://foo..areas/, get, json}
        {http, http://.../, post, xml}

* Support global configs for all tx/rx and per instance configuration
  overriding, this would allow, different one application to use say multiple
  smsc accounts for proper load-balancing, etc.

  Also, extend this to support virtual instances, which would basically be like
  the entire application with its own seperate configuration, running still
  inside one vm instance.

* Start employing erlang:monitor/2 across board to handle garbage collection of
  dead/dying procs:
    * backoff needs to deregister its dying clients
    * nanny's need to deregister their dying kids so when the new ones
      come back, they can replace them cleanly.
    * other such shenanigans :)
